import numpy as np
# a_zeros = np.zeros(4)
# print(a_zeros)
# a_zeros1 = np.zeros((3,4))
# print(a_zeros1)
# a_one = np.ones(5)
# print(a_one)
# a_one1 = np.ones((4,5))
# print(a_one1)
a_one = np.ones((3,3))
print(a_one)

a_empty = np.empty((3,3))  #this shit contains last updated memory of similar array inside it
print(a_empty)

a_range = np.arange(5)
print(a_range)
arr1 = np.random.rand(2,3)
arr2 = np.random.randn(2,2,2)
print(arr2)
arr3 = np.random.randint(10,100,10)
print(arr3)

-----------------------------------------------------
integer - i
boolean - b
unsigned integer - u
float - f
complex float - c
timedelta - m
datetime - M
object - O
string - S
Unicode string - U
the fixed chunk of memory for other types(void) -V
-----------------------------------------------------

#setting data type in numpy
#way 1
arr1  = np.int8([1,2,3,4,5,4])
print(arr1)
print(arr1.dtype)
#way 2
arr2 = np.array([12,34,54,65,33] , dtype=np.int16)
print(arr2.dtype , type(arr2))
#way 3
arr3 = np.array([12,4,1,57,52,96,45] , dtype= "f")
print(arr3.dtype)

#way 4
arr4 = np.array([12,354,63,63,64,23])
arr5 = np.astype(arr4 , np.float128)
print(arr4.dtype ,arr5.dtype)


------------------------------------------------------
a + b               np.add(a,b)
a - b               np.subtract(a,b)
a \ b               np.divide(a,b)
a * b               np.multiple(a,b)
a % b               np.mod(a,b)
a ** b              np.pow(a,b)
1/a                 np.reciprocal(a)
------------------------------------------------------

#using arithematic operators
#there are two specific formats for the thing
#for one dimension
arr1 = np.array([1,2,3,4])
print(np.add(arr1 , 6))
arr2 = np.array([12,34,53,21])
print(np.subtract(arr1 , arr2))
print(np.multiply(arr1,arr2))
arr3 = np.astype(np.divide(arr2 , arr1) , np.int16)
print(arr3 , arr3.dtype)
arr4 = np.astype(np.reciprocal(np.array([12,23,34,45])) , np.float32)
print(arr4)

#for 2
arr2_1 = np.array([[2,3,4] , [5,6,7] , [12,34,45]])
arr2_2 = np.array([[4,25,85] , [54,25,6] , [7,5,1]])
print(arr2_1 + arr2_2)
print(arr2_1 * arr2_2)
print(arr2_1 / arr2_2)
print(arr2_1 - arr2_2)


--------------------------------------------------
arithematic functions
np.min(x)
np.max(x)
np.argmin(x)     index of minimum value
np.argmax(x)
np.sqrt(x)
np.cos(x)
np.sin(x)
np.cumsum(x)      cummulative summation
--------------------------------------------------

axis ->0  = whats under first bracket
axis ->1 = whats under next bracket
axis ->2 = whats under next to next bracket

for shapping until the total no. of elements are equal to multiplication of row and columns you can make any kind of fucking array


arr1 = np.array([15,64,84,35])
arr2 = np.array([[12,23,34] , [23,34,45]])
arr3 = np.array([[12,134,143] , [12,32 ,78]])
print(arr1 , arr2 , arr3 , sep = "\n")
print(arr1.shape , arr2.shape , arr3.shape ,sep="\n")

arr4 = arr3.reshape(3,2)
print(arr4)


#broadcasting

Rule 1:- the dimension needs to be same
Rule 2:- if dimension not same then atleast one of the rightmost value of dimensions should be 1 , do the same with
all values going from right to leftgit
Rule 3:- the dimension after broadcasting is the maximum element of respective place of dimension

arr2 = np.array([[12,23,34] , [23,34,45]])
print(arr1.shape , arr2.shape ,sep="\n")
print(arr1+arr2)
arr3 = np.array([1,2,3,4,5,6])
arr = arr3.reshape(3,2,1)
print(arr)
arr4 = np.array([1,2,3,4,5,6,7,8,9,10,11,12])
arr_ = arr4.reshape(3,2,2)
print(arr_)
print(arr+arr_)



indexing and slicing is same as lists in array

use of nditer to iterate the elements inside the array
or else using for loop

#copy vs view
copy - a copy of the array with different location
        any chnges made in original will not alter the copy of its
view - a copy of the array with the same loccation
        any changes made in original will alter the copy too

        modifying the view array will also affect the original array
        â€” because they share the same underlying data memory.



concatenation -- only use when a new axis is not needed to be added ,
                    when u have to work on existing axis
                    like if shape is (2,1) which is usualy [2,]
                    then only axis 0 could be concatenated

stack -- jab new axis banani ho
           agar aangi baangi banani hai to use kro bahi ek baar tutorial dekh le revise ke liye
            baaki easy h

jatin = np.array([[1,2]])
ria = np.array([[1,2],[2,3]])

# shaurya = np.concatenate((jatin , ria) , axis=0)

# print(shaurya)
# yrr concatenation ya stack dono use krte hue dimag lagana hai ki konsi
# dimension use ho skti ha konsi nhi dhyaan se koi hard and fine rule nhi hai

jispa = np.array([1,2,3])
village = np.array([4,5,6])
jispa_village = np.concatenate((jispa , village) , axis=0)
print(jispa_village)
jipsa_cillage = np.stack((jispa , village) , axis=0)
print(jipsa_cillage)
jipsa_cillage1 = np.stack((jispa , village) , axis=1)
print(jipsa_cillage1)


jasmin  = np.array([[["roya mai" , "teri saari" ,"batein cudi"],["mil jaye" , "jo bhi" , "raaj tera"],
                     ["tu aata" , "sambhal kr" , "rkha wo"]],[["wo phool","mera tu" , "adhuri si"],["ab hisse" , "rhna tha" ,"bnke hm"]
    ,["pr tu" , "atta nhi " ,"jaata wahin"]]])
rahul = np.array([[[1,2,3] ,[2,3,4] ,[3,4,5]]
                     ,[[5,6,7],[6,7,8],[7,8,9]]])

# print(jasmin)
# print(rahul)

# jasrahul = np.stack((jasmin,rahul) , axis=0)
# jasrahul1 = np.stack((jasmin,rahul) , axis=1)
# jasrahul2 = np.stack((jasmin,rahul) , axis=2)
# print(jasrahul)
# print(jasrahul1)
# print(jasrahul2)

j = np.array([[["a","b","c"] ,["a","b","c"],["a","b","c"]]
                 ,[["a","b","c"],["a","b","c"],["a","b","c"]]])
k = np.array([[[1,2,3] ,[2,3,4] ,[3,4,5]]
                     ,[[5,6,7],[6,7,8],[7,8,9]]])
j1 = np.stack((j ,k) , axis=0)
j2 = np.stack((j ,k) , axis=1)
j3 = np.stack((j ,k) , axis=2)
print(j1)
print("")
print(j2)
print("")
print(j3)